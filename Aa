local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")

-- Configuration
local WAYPOINT_OFFSET = Vector3.new(0, 3, 0) -- Height above target's head
local FOLLOW_POINT_OFFSET = Vector3.new(0, 0, -5) -- Behind the waypoint
local RECALCULATE_INTERVAL = 1.5
local TARGET_REACH_DISTANCE = 8
local WAYPOINT_REACH_DISTANCE = 4
local PREDICTION_FACTOR = 0.7
local DEBUG_VISUAL = true

-- Create waypoint for target player
local function createWaypoint(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return nil end
    
    -- Create waypoint part
    local waypoint = Instance.new("Part")
    waypoint.Name = "TargetWaypoint"
    waypoint.Size = Vector3.new(2, 2, 2)
    waypoint.Transparency = 1
    waypoint.CanCollide = false
    waypoint.Anchored = true
    waypoint.Parent = workspace
    
    -- Create visual indicator if debug is enabled
    if DEBUG_VISUAL then
        local marker = Instance.new("Part")
        marker.Name = "WaypointMarker"
        marker.Size = Vector3.new(3, 3, 3)
        marker.Shape = Enum.PartType.Ball
        marker.Color = Color3.fromRGB(255, 50, 50) -- Red
        marker.Material = Enum.Material.Neon
        marker.Transparency = 0.3
        marker.CanCollide = false
        marker.Anchored = true
        marker.Parent = waypoint
        
        local light = Instance.new("PointLight")
        light.Brightness = 2
        light.Range = 20
        light.Color = Color3.fromRGB(255, 100, 100)
        light.Parent = marker
    end
    
    -- Update position to follow target
    RunService.Heartbeat:Connect(function()
        if not waypoint or not waypoint.Parent then return end
        if not targetPlayer or not targetPlayer.Character then return end
        
        local root = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not root then return end
        
        -- Predict movement
        local velocity = root.AssemblyLinearVelocity
        local predictedOffset = WAYPOINT_OFFSET + (velocity * PREDICTION_FACTOR)
        
        -- Apply smooth movement
        waypoint.CFrame = root.CFrame:ToWorldSpace(CFrame.new(predictedOffset))
    end)
    
    return waypoint
end

-- Create follow point for the follower
local function createFollowPoint()
    local followPoint = Instance.new("Part")
    followPoint.Name = "FollowPoint"
    followPoint.Size = Vector3.new(2, 2, 2)
    followPoint.Transparency = 1
    followPoint.CanCollide = false
    followPoint.Anchored = true
    followPoint.Parent = workspace
    
    -- Create visual indicator if debug is enabled
    if DEBUG_VISUAL then
        local marker = Instance.new("Part")
        marker.Name = "FollowMarker"
        marker.Size = Vector3.new(2.5, 2.5, 2.5)
        marker.Shape = Enum.PartType.Ball
        marker.Color = Color3.fromRGB(50, 150, 255) -- Blue
        marker.Material = Enum.Material.Neon
        marker.Transparency = 0.3
        marker.CanCollide = false
        marker.Anchored = true
        marker.Parent = followPoint
        
        local light = Instance.new("PointLight")
        light.Brightness = 2
        light.Range = 15
        light.Color = Color3.fromRGB(100, 150, 255)
        light.Parent = marker
    end
    
    return followPoint
end

-- Make follow point track the waypoint
local function trackWaypoint(followPoint, waypoint)
    RunService.Heartbeat:Connect(function()
        if not followPoint or not followPoint.Parent then return end
        if not waypoint or not waypoint.Parent then return end
        
        -- Calculate position behind the waypoint
        local offset = waypoint.CFrame:VectorToWorldSpace(FOLLOW_POINT_OFFSET)
        local targetPosition = waypoint.Position + offset
        
        -- Smooth movement
        followPoint.CFrame = CFrame.new(followPoint.Position:Lerp(targetPosition, 0.3))
    end)
end

-- Pathfinding to follow the point
local function followPoint(followPoint)
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    
    local active = true
    local connection
    local lastRecalculation = 0
    local currentPath = {}
    local currentWaypointIndex = 1
    
    -- Clear previous visualization
    for _, child in ipairs(workspace:GetChildren()) do
        if child.Name == "PathMarker" then
            child:Destroy()
        end
    end
    
    connection = RunService.Heartbeat:Connect(function()
        if not active then return end
        if not humanoid or humanoid.Health <= 0 then 
            active = false
            return 
        end
        
        -- Check distance to follow point
        local distance = (followPoint.Position - rootPart.Position).Magnitude
        if distance < TARGET_REACH_DISTANCE then
            humanoid:MoveTo(followPoint.Position)
            return
        end
        
        -- Throttle path recalculations
        local now = tick()
        if now - lastRecalculation < RECALCULATE_INTERVAL then
            -- Continue following current path if available
            if #currentPath > 0 and currentWaypointIndex <= #currentPath then
                local waypoint = currentPath[currentWaypointIndex]
                humanoid:MoveTo(waypoint.Position)
                
                -- Check if reached waypoint
                if (waypoint.Position - rootPart.Position).Magnitude < WAYPOINT_REACH_DISTANCE then
                    currentWaypointIndex += 1
                end
                
                -- Handle jumps
                if waypoint.Action == Enum.PathWaypointAction.Jump then
                    humanoid.Jump = true
                end
            end
            return
        end
        
        lastRecalculation = now
        
        -- Create new path
        local path = PathfindingService:CreatePath({
            AgentRadius = 2.5,
            AgentHeight = 5,
            AgentCanJump = true,
            AgentCanClimb = true,
            WaypointSpacing = 6
        })
        
        path:ComputeAsync(rootPart.Position, followPoint.Position)
        
        if path.Status == Enum.PathStatus.Success then
            currentPath = path:GetWaypoints()
            currentWaypointIndex = 1
            
            -- Create visual path markers if debug enabled
            if DEBUG_VISUAL then
                for i, waypoint in ipairs(currentPath) do
                    local marker = Instance.new("Part")
                    marker.Name = "PathMarker"
                    marker.Size = Vector3.new(1, 1, 1)
                    marker.Position = waypoint.Position
                    marker.Anchored = true
                    marker.CanCollide = false
                    marker.Transparency = 0.7
                    marker.Color = Color3.fromRGB(50, 255, 50) -- Green
                    marker.Material = Enum.Material.Neon
                    marker.Parent = workspace
                    
                    -- Add number label
                    local billboard = Instance.new("BillboardGui")
                    billboard.Size = UDim2.new(2, 0, 2, 0)
                    billboard.AlwaysOnTop = true
                    billboard.Adornee = marker
                    
                    local label = Instance.new("TextLabel")
                    label.Size = UDim2.new(1, 0, 1, 0)
                    label.Text = tostring(i)
                    label.Font = Enum.Font.SciFi
                    label.TextSize = 14
                    label.BackgroundTransparency = 1
                    label.TextColor3 = Color3.new(1, 1, 1)
                    label.Parent = billboard
                    
                    billboard.Parent = marker
                    
                    -- Auto-cleanup
                    game:GetService("Debris"):AddItem(marker, 10)
                end
            end
        else
            -- Fallback to direct movement
            humanoid:MoveTo(followPoint.Position)
        end
    end)
    
    return {
        stop = function()
            active = false
            if connection then
                connection:Disconnect()
            end
        end
    }
end

-- Main follow function
local function followPlayer(targetPlayerName)
    -- Find target player
    local targetPlayer
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name:lower():find(targetPlayerName:lower(), 1, true) then
            targetPlayer = player
            break
        end
    end
    
    if not targetPlayer then
        warn("Player not found:", targetPlayerName)
        return
    end
    
    -- Create waypoint for target
    local waypoint = createWaypoint(targetPlayer)
    if not waypoint then
        warn("Failed to create waypoint for", targetPlayerName)
        return
    end
    
    -- Create follow point
    local followPoint = createFollowPoint()
    
    -- Make follow point track the waypoint
    trackWaypoint(followPoint, waypoint)
    
    -- Start pathfinding to follow point
    local followController = followPoint(followPoint)
    
    -- Return control interface
    return {
        stop = function()
            if followController then
                followController.stop()
            end
            if waypoint then
                waypoint:Destroy()
            end
            if followPoint then
                followPoint:Destroy()
            end
        end,
        getWaypoint = function() return waypoint end,
        getFollowPoint = function() return followPoint end
    }
end

-- Example usage:
--[[
local follower = followPlayer("TargetPlayerName")

-- To stop following later:
-- follower.stop()
]]--

-- Command interface for executors
return {
    follow = followPlayer,
    stopAll = function()
        for _, child in ipairs(workspace:GetChildren()) do
            if child.Name == "TargetWaypoint" or child.Name == "FollowPoint" then
                child:Destroy()
            end
        end
    end
}
