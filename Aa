local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")

-- Configuration
local RECALCULATE_INTERVAL = 1.5  -- Seconds between path recalculations
local TARGET_REACH_DISTANCE = 8   -- Distance to consider target reached
local WAYPOINT_REACH_DISTANCE = 4 -- Distance to consider waypoint reached
local PREDICTION_FACTOR = 0.7     -- Target position prediction (0-1)
local DEBUG_VISUAL = true         -- Set to false to disable path visualization
local MOVEMENT_SMOOTHING = 0.2    -- Smoothing factor for movement transitions (0-1)

-- Pathfinder state
local active = false
local connection = nil
local debugParts = {}
local targetPlayer = nil
local currentPath = {}
local currentWaypointIndex = 1
local lastRecalculation = 0
local lastTargetPosition = Vector3.new(0, 0, 0)
local isMoving = false
local movementGoal = nil
local movementStartTime = 0

-- Clear visualization
local function clearVisualization()
    for _, part in ipairs(debugParts) do
        if part and part.Parent then
            part:Destroy()
        end
    end
    debugParts = {}
end

-- Create visualization for path
local function visualizePath(pathWaypoints)
    if not DEBUG_VISUAL then return end
    clearVisualization()
    
    for i, waypoint in ipairs(pathWaypoints) do
        local part = Instance.new("Part")
        part.Size = Vector3.new(0.6, 0.6, 0.6)
        part.Position = waypoint.Position
        part.Anchored = true
        part.CanCollide = false
        part.Transparency = 0.4
        part.Material = Enum.Material.Neon
        
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            part.Color = Color3.fromRGB(100, 150, 255) -- Blue for jump
        else
            part.Color = Color3.fromRGB(100, 255, 100) -- Green for normal
        end
        
        part.Parent = workspace
        table.insert(debugParts, part)
        
        -- Add label for waypoint number
        local billboard = Instance.new("BillboardGui")
        billboard.Size = UDim2.new(3, 0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Adornee = part
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = tostring(i)
        label.Font = Enum.Font.SciFi
        label.TextSize = 18
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.new(1, 1, 1)
        label.TextStrokeTransparency = 0.5
        label.Parent = billboard
        
        billboard.Parent = part
    end
end

-- Continuous movement function
local function updateMovement(humanoid, rootPart, targetPosition)
    if not active or not humanoid or not rootPart then return end
    
    -- Only update if we have a new goal or we're close to current goal
    if not movementGoal or (movementGoal - rootPart.Position).Magnitude < WAYPOINT_REACH_DISTANCE then
        movementGoal = targetPosition
        movementStartTime = tick()
        humanoid:MoveTo(targetPosition)
    end
    
    -- Apply movement smoothing
    if MOVEMENT_SMOOTHING > 0 then
        local currentPosition = rootPart.Position
        local direction = (movementGoal - currentPosition).Unit
        local distance = (movementGoal - currentPosition).Magnitude
        
        -- Only apply smoothing when we're not too close
        if distance > WAYPOINT_REACH_DISTANCE * 2 then
            local smoothedGoal = currentPosition + (direction * distance * MOVEMENT_SMOOTHING)
            humanoid:MoveTo(smoothedGoal)
        end
    end
    
    -- Handle jumps at waypoints
    for _, waypoint in ipairs(currentPath) do
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            local distanceToJump = (waypoint.Position - rootPart.Position).Magnitude
            if distanceToJump < WAYPOINT_REACH_DISTANCE * 1.5 then
                humanoid.Jump = true
            end
        end
    end
    
    -- Check if stuck
    if tick() - movementStartTime > 2 and (movementGoal - rootPart.Position).Magnitude > WAYPOINT_REACH_DISTANCE then
        humanoid.Jump = true
        task.wait(0.1)
        humanoid.Jump = true
        movementGoal = nil -- Force new movement command
    end
end

-- Predictive path calculation
local function calculatePredictivePath(rootPart, targetRoot)
    -- Predict target's future position
    local targetVelocity = targetRoot.AssemblyLinearVelocity
    local predictedPosition = targetRoot.Position + (targetVelocity * PREDICTION_FACTOR)
    
    -- Create path
    local path = PathfindingService:CreatePath({
        AgentRadius = 2.5,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,
        WaypointSpacing = 6,  -- Larger spacing for smoother paths
        Cost = {}
    })
    
    -- Compute path to predicted position
    path:ComputeAsync(rootPart.Position, predictedPosition)
    
    if path.Status == Enum.PathStatus.Success then
        return path:GetWaypoints()
    end
    
    -- Fallback to current position if prediction fails
    path:ComputeAsync(rootPart.Position, targetRoot.Position)
    if path.Status == Enum.PathStatus.Success then
        return path:GetWaypoints()
    end
    
    return nil
end

-- Path recalculation thread
local function startPathRecalculationThread(rootPart, targetRoot)
    while active and task.wait(RECALCULATE_INTERVAL) do
        if not active then break end
        
        -- Skip if target hasn't moved significantly
        local targetMoved = (lastTargetPosition - targetRoot.Position).Magnitude > 5
        if not targetMoved and #currentPath > 0 then
            -- Advance to next waypoint if we're close to current
            if currentWaypointIndex <= #currentPath then
                local waypoint = currentPath[currentWaypointIndex]
                if (waypoint.Position - rootPart.Position).Magnitude < WAYPOINT_REACH_DISTANCE * 1.5 then
                    currentWaypointIndex = math.min(currentWaypointIndex + 1, #currentPath)
                end
            end
            continue
        end
        
        -- Recalculate path
        lastTargetPosition = targetRoot.Position
        local newWaypoints = calculatePredictivePath(rootPart, targetRoot)
        
        if newWaypoints and #newWaypoints > 0 then
            currentPath = newWaypoints
            visualizePath(currentPath)
            
            -- Find the closest waypoint in the new path
            local closestIndex = 1
            local closestDist = math.huge
            for i, waypoint in ipairs(currentPath) do
                local dist = (waypoint.Position - rootPart.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestIndex = i
                end
            end
            
            -- Skip ahead to the closest waypoint
            currentWaypointIndex = math.min(closestIndex, #currentPath)
        end
    end
end

-- Start pathfinding to a player
local function followPlayer(playerName)
    -- Clear previous state
    if connection then
        connection:Disconnect()
        connection = nil
    end
    clearVisualization()
    
    -- Find target player
    targetPlayer = nil
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name:lower():find(playerName:lower(), 1, true) then
            targetPlayer = player
            break
        end
    end
    
    if not targetPlayer then
        warn("Player not found:", playerName)
        return false
    end
    
    -- Get local player references
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    
    active = true
    currentPath = {}
    currentWaypointIndex = 1
    lastRecalculation = 0
    lastTargetPosition = Vector3.new(0, 0, 0)
    movementGoal = nil
    
    -- Start path recalculation in separate thread
    task.spawn(function()
        startPathRecalculationThread(rootPart, targetPlayer.Character:WaitForChild("HumanoidRootPart"))
    end)
    
    -- Main movement loop
    connection = RunService.Heartbeat:Connect(function()
        if not active then return end
        if not humanoid or humanoid.Health <= 0 then 
            active = false
            return 
        end
        
        -- Check if target is still valid
        if not targetPlayer or not targetPlayer.Parent or not targetPlayer.Character then
            active = false
            return
        end
        
        local targetChar = targetPlayer.Character
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if not targetRoot then 
            active = false
            return 
        end
        
        -- Check if we've reached the target
        local distanceToTarget = (targetRoot.Position - rootPart.Position).Magnitude
        if distanceToTarget < TARGET_REACH_DISTANCE then
            updateMovement(humanoid, rootPart, targetRoot.Position)
            return
        end
        
        -- Follow current path if available
        if #currentPath > 0 and currentWaypointIndex <= #currentPath then
            local waypoint = currentPath[currentWaypointIndex]
            updateMovement(humanoid, rootPart, waypoint.Position)
        else
            -- Move directly if we have no path
            updateMovement(humanoid, rootPart, targetRoot.Position)
        end
    end)
    
    return true
end

-- Stop pathfinding
local function stopFollowing()
    active = false
    if connection then
        connection:Disconnect()
        connection = nil
    end
    clearVisualization()
end

-- Command interface
return {
    follow = followPlayer,
    stop = stopFollowing,
    toggleDebug = function() DEBUG_VISUAL = not DEBUG_VISUAL end,
    setSmoothing = function(value) MOVEMENT_SMOOTHING = math.clamp(value, 0, 1) end
}
