local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")

-- Configuration
local RECALCULATE_INTERVAL = 1.5  -- Seconds between path recalculations
local TARGET_REACH_DISTANCE = 8   -- Distance to consider target reached
local WAYPOINT_REACH_DISTANCE = 4 -- Distance to consider waypoint reached
local PREDICTION_FACTOR = 0.7     -- Target position prediction (0-1)
local DEBUG_VISUAL = true         -- Set to false to disable path visualization
local MOVEMENT_SMOOTHING = 0.2    -- Smoothing factor for movement transitions

-- Pathfinder state
local active = false
local connection = nil
local debugParts = {}
local targetPlayer = nil
local currentPath = {}
local currentWaypointIndex = 1
local lastRecalculation = 0
local lastTargetPosition = Vector3.new(0, 0, 0)
local movementGoal = nil
local movementStartTime = 0

-- Safe instance access function
local function safeGet(instance, path)
    local current = instance
    for _, name in ipairs(path) do
        if not current then return nil end
        current = current:FindFirstChild(name)
    end
    return current
end

-- Clear visualization
local function clearVisualization()
    for _, part in ipairs(debugParts) do
        if part and part.Parent then
            part:Destroy()
        end
    end
    debugParts = {}
end

-- Create visualization for path
local function visualizePath(pathWaypoints)
    if not DEBUG_VISUAL then return end
    clearVisualization()
    
    for i, waypoint in ipairs(pathWaypoints) do
        local part = Instance.new("Part")
        part.Size = Vector3.new(0.6, 0.6, 0.6)
        part.Position = waypoint.Position
        part.Anchored = true
        part.CanCollide = false
        part.Transparency = 0.4
        part.Material = Enum.Material.Neon
        
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            part.Color = Color3.fromRGB(100, 150, 255) -- Blue for jump
        else
            part.Color = Color3.fromRGB(100, 255, 100) -- Green for normal
        end
        
        part.Parent = workspace
        table.insert(debugParts, part)
        
        -- Add label for waypoint number
        local billboard = Instance.new("BillboardGui")
        billboard.Size = UDim2.new(3, 0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Adornee = part
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = tostring(i)
        label.Font = Enum.Font.SciFi
        label.TextSize = 18
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.new(1, 1, 1)
        label.TextStrokeTransparency = 0.5
        label.Parent = billboard
        
        billboard.Parent = part
    end
end

-- Continuous movement function with instance validation
local function updateMovement()
    if not active then return end
    
    local player = Players.LocalPlayer
    if not player then return end
    
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart or humanoid.Health <= 0 then
        return
    end
    
    -- Only update if we have a new goal or we're close to current goal
    if not movementGoal or (movementGoal - rootPart.Position).Magnitude < WAYPOINT_REACH_DISTANCE then
        movementGoal = currentPath[currentWaypointIndex] and currentPath[currentWaypointIndex].Position
        movementStartTime = tick()
        if movementGoal then
            humanoid:MoveTo(movementGoal)
        end
    end
    
    -- Apply movement smoothing
    if MOVEMENT_SMOOTHING > 0 and movementGoal then
        local currentPosition = rootPart.Position
        local direction = (movementGoal - currentPosition).Unit
        local distance = (movementGoal - currentPosition).Magnitude
        
        -- Only apply smoothing when we're not too close
        if distance > WAYPOINT_REACH_DISTANCE * 2 then
            local smoothedGoal = currentPosition + (direction * distance * MOVEMENT_SMOOTHING)
            humanoid:MoveTo(smoothedGoal)
        end
    end
    
    -- Handle jumps at waypoints
    if currentPath[currentWaypointIndex] and currentPath[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then
        humanoid.Jump = true
    end
    
    -- Check if stuck
    if movementGoal and tick() - movementStartTime > 2 and (movementGoal - rootPart.Position).Magnitude > WAYPOINT_REACH_DISTANCE then
        humanoid.Jump = true
        task.wait(0.1)
        humanoid.Jump = true
        movementGoal = nil -- Force new movement command
    end
end

-- Predictive path calculation with instance validation
local function calculatePredictivePath()
    local player = Players.LocalPlayer
    if not player then return nil end
    
    local character = player.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    if not targetPlayer or not targetPlayer.Parent or not targetPlayer.Character then
        return nil
    end
    
    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return nil end
    
    -- Predict target's future position
    local targetVelocity = targetRoot.AssemblyLinearVelocity
    local predictedPosition = targetRoot.Position + (targetVelocity * PREDICTION_FACTOR)
    
    -- Create path
    local path = PathfindingService:CreatePath({
        AgentRadius = 2.5,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true,
        WaypointSpacing = 6,
    })
    
    -- Compute path to predicted position
    local success, status = pcall(function()
        path:ComputeAsync(rootPart.Position, predictedPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        return path:GetWaypoints()
    end
    
    -- Fallback to current position
    success, status = pcall(function()
        path:ComputeAsync(rootPart.Position, targetRoot.Position)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        return path:GetWaypoints()
    end
    
    return nil
end

-- Path recalculation thread
local function pathRecalculationLoop()
    while active do
        task.wait(RECALCULATE_INTERVAL)
        if not active then break end
        
        -- Get current player position
        local player = Players.LocalPlayer
        if not player then continue end
        
        local character = player.Character
        if not character then continue end
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then continue end
        
        -- Get target position
        if not targetPlayer or not targetPlayer.Parent or not targetPlayer.Character then
            continue
        end
        
        local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not targetRoot then continue end
        
        -- Skip if target hasn't moved significantly
        local targetMoved = (lastTargetPosition - targetRoot.Position).Magnitude > 5
        lastTargetPosition = targetRoot.Position
        
        if not targetMoved and #currentPath > 0 then
            -- Advance to next waypoint if we're close to current
            if currentWaypointIndex <= #currentPath then
                local waypoint = currentPath[currentWaypointIndex]
                if (waypoint.Position - rootPart.Position).Magnitude < WAYPOINT_REACH_DISTANCE * 1.5 then
                    currentWaypointIndex = math.min(currentWaypointIndex + 1, #currentPath)
                end
            end
            continue
        end
        
        -- Recalculate path
        local newWaypoints = calculatePredictivePath()
        
        if newWaypoints and #newWaypoints > 0 then
            currentPath = newWaypoints
            visualizePath(currentPath)
            
            -- Find the closest waypoint in the new path
            local closestIndex = 1
            local closestDist = math.huge
            for i, waypoint in ipairs(currentPath) do
                local dist = (waypoint.Position - rootPart.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestIndex = i
                end
            end
            
            -- Skip ahead to the closest waypoint
            currentWaypointIndex = math.min(closestIndex, #currentPath)
        end
    end
end

-- Start pathfinding to a player
local function followPlayer(playerName)
    -- Clear previous state
    stopFollowing()
    clearVisualization()
    
    -- Find target player
    targetPlayer = nil
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name:lower():find(playerName:lower(), 1, true) then
            targetPlayer = player
            break
        end
    end
    
    if not targetPlayer then
        warn("Player not found:", playerName)
        return false
    end
    
    active = true
    currentPath = {}
    currentWaypointIndex = 1
    lastRecalculation = 0
    lastTargetPosition = Vector3.new(0, 0, 0)
    movementGoal = nil
    
    -- Start path recalculation in separate thread
    task.spawn(pathRecalculationLoop)
    
    -- Main movement loop
    connection = RunService.Heartbeat:Connect(function()
        if not active then return end
        
        -- Update movement with validation
        local success, err = pcall(updateMovement)
        if not success then
            warn("Movement error:", err)
            stopFollowing()
        end
    end)
    
    return true
end

-- Stop pathfinding
local function stopFollowing()
    active = false
    if connection then
        connection:Disconnect()
        connection = nil
    end
    clearVisualization()
end

-- Command interface
return {
    follow = followPlayer,
    stop = stopFollowing,
    toggleDebug = function() DEBUG_VISUAL = not DEBUG_VISUAL end,
    setSmoothing = function(value) MOVEMENT_SMOOTHING = math.clamp(value, 0, 1) end
}
